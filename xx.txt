#include <iostream>
#include <fstream>
#include <cmath>
#include <ostream>
#include <array>
using namespace std;
const int startX = 1;
const int startY = 1;
const int destX = 4;
const int destY = 4;
const int maxX = 5;
const int maxY = 5;

double hVal(int x,int y,int destX, int destY)
{
    double h=sqrt(pow(x - destX, 2) + pow(y - destY, 2));
    return h;
}

void grid_path_reverse(int x,int y,int startX,int startY,int grid[maxX][maxY],int directions[maxX][maxY],int moveX[4],int moveY[4])
{
    while(x != startX || y != startY)
    {
        grid[x][y]=3;
        if(directions[x][y]==1)
        {
            y+=moveY[1];
            grid[x][y]=3;
        }
        if(directions[x][y]==2)
        {
            y+=moveY[0];
            grid[x][y]=3;
        }
        if(directions[x][y]==3)
        {
            x+=moveX[3];
            grid[x][y]=3;
        }
        if(directions[x][y]==4)
        {
            x+=moveX[2];
            grid[x][y]=3;
        }
    }
}

void print_array(int arr[maxX][maxY])
{
    cout<<endl;
    for(int i=0;i<maxX;i++)
    {
        for(int j=0;j<maxY;j++)
        {
            cout<<arr[i][j]<<" ";
        }
        cout<<endl;
    }
}

int main()
{
    ifstream file;
    file.open("grid.txt");
    int moveX[4]={0,0,-1,1}; //ruch lewo prawo
    int moveY[4]={1,-1,0,0}; //ruch gora dol
    int curX=startX; //rodzic X
    int curY=startY; //rodzic Y
    int minX = 0;
    int minY = 0;
    int x = destX,y = destY;
    int openList[maxX][maxY] = {};
    int closedList[maxX][maxY] = {};
    int grid[maxX][maxY] = {};
    int directions[maxX][maxY] = {};
    double values[maxX][maxY] = {};
    double distance[maxX][maxY] = {};
    //inicjalizacja grida
    for(int i=0;i<maxY;i++)
    {
        for(int j=0;j<maxX;j++)
        {
            file >> grid[i][j];
        }
    }
while(closedList[destX][destY]==0) //glowna petla konczy dzialanie gdy zamknieta lista dojdzie do celu
{
    if(grid[startX][startY]==5)
    {
        cout<<"start jest sciana"<<endl;
        break;
    }
    if(grid[destX][destY]==5)
    {
        cout<<"koniec jest sciana"<<endl;
        break;
    }
    closedList[curX][curY] = 1;
    for(int i=0;i<4;i++) //petla ruszajaca sie gora dol lewa prawa po tablicy
    {

        int tmpX,tmpY = 0;
        tmpX = curX+moveX[i]; //dziecko curX
        tmpY = curY+moveY[i]; //dziecko curY
        if(grid[tmpX][tmpY] == 5 || closedList[tmpX][tmpY] == 1 || tmpX < 0 || tmpY < 0 || tmpX > maxX-1 || tmpY > maxY-1)
        {
            continue;
        }
        distance[tmpX][tmpY]=distance[curX][curY]+1; //dystans od pola [tmpX][tmpY] do startu
        double fVal = distance[tmpX][tmpY]+hVal(tmpX,tmpY,destX,destY); //obliczanie f(poz)=g(poz)+h(poz)
        if(openList[tmpX][tmpY] == 0 || values[tmpX][tmpY]>fVal) //przypisanie indeksom tablicy values wartosci pola i tablicy openList informacji o rodzicu
        {
            directions[tmpX][tmpY] = 1+i;
            openList[tmpX][tmpY] = 1;
            values[tmpX][tmpY] = fVal;
        }
    }
    double tmpValue = 0;
    for(int i=0;i<maxX;i++)
    {
        for(int j=0;j<maxY;j++)
        {
            if(closedList[i][j] == 0 && (values[i][j] <= tmpValue && values[i][j] != 0) || tmpValue == 0 && grid[i][j]!=5)
            {
                tmpValue = values[i][j];
                minX = i;
                minY = j;
            }
        }
    }
    curX = minX;
    curY = minY;
    openList[curX][curY]=0;
}
print_array(openList);
print_array(closedList);
print_array(directions);
grid_path_reverse(x,y,startX,startY,grid,directions,moveX,moveY);
print_array(grid);
    return 0;
}

